{"version":3,"file":"index.es.js","sources":["../src/atom/atom-list.ts","../src/composable/$command.ts","../src/composable/$inputRule.ts","../src/composable/$mark.ts","../src/composable/$node.ts","../src/composable/$prose.ts","../src/composable/$remark.ts","../src/composable/$shortcut.ts","../src/composable/$view.ts","../src/factory/common.ts","../src/factory/create-mark.ts","../src/factory/create-node.ts","../src/factory/create-plugin.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\n\nimport { MilkdownPlugin } from '@milkdown/core';\n\nimport { AddMetadata, Metadata } from '../types';\n\ntype PluginWithMetadata = MilkdownPlugin & Metadata;\ntype Plugin = MilkdownPlugin | PluginWithMetadata;\n\nconst hasMetadata = (x: Plugin): x is PluginWithMetadata => Object.prototype.hasOwnProperty.call(x, 'origin');\n\ntype Factory = AddMetadata;\n\nexport class AtomList<T extends Plugin = Plugin> extends Array<T> {\n    private findThenRun<U extends Factory>(target: U, callback: (index: number) => void): this {\n        const index = this.findIndex((x) => hasMetadata(x) && x.origin === target);\n        if (index < 0) return this;\n\n        callback(index);\n\n        return this;\n    }\n\n    configure<U extends Factory>(target: U, config: Parameters<U>[0]): this {\n        return this.findThenRun(target, (index) => {\n            this.splice(index, 1, target(config) as T);\n        });\n    }\n\n    replace<U extends Factory, Next extends Plugin>(target: U, next: Next): this {\n        return this.findThenRun(target, (index) => {\n            this.splice(index, 1, next as Plugin as T);\n        });\n    }\n\n    remove<U extends Factory>(target: U): this {\n        return this.findThenRun(target, (index) => {\n            this.splice(index, 1);\n        });\n    }\n\n    headless(): this {\n        this.filter(hasMetadata).forEach((x) => {\n            this.configure((x as PluginWithMetadata).origin as Factory, { headless: true });\n        });\n        return this;\n    }\n\n    static create<T extends Plugin = Plugin>(from: T[]): AtomList<T> {\n        return new AtomList(...from);\n    }\n}\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { CmdKey, CmdTuple, commandsCtx, Ctx, MilkdownPlugin, SchemaReady } from '@milkdown/core';\n\nexport type $Command<T> = MilkdownPlugin & {\n    run: (info?: T) => boolean;\n    key: CmdKey<T>;\n};\n\nexport const $command = <T>(cmd: (ctx: Ctx) => CmdTuple<T>): $Command<T> => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(SchemaReady);\n        const [key, command] = cmd(ctx);\n        ctx.get(commandsCtx).create(key, command);\n        (<$Command<T>>plugin).run = (info?: T) => ctx.get(commandsCtx).call(key, info);\n        (<$Command<T>>plugin).key = key;\n    };\n\n    return <$Command<T>>plugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, inputRulesCtx, MilkdownPlugin, SchemaReady } from '@milkdown/core';\nimport { InputRule } from '@milkdown/prose';\n\nexport type $InputRule = MilkdownPlugin & {\n    inputRule: InputRule;\n};\n\nexport const $inputRule = (inputRule: (ctx: Ctx) => InputRule): $InputRule => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(SchemaReady);\n        const ir = inputRule(ctx);\n        ctx.update(inputRulesCtx, (irs) => [...irs, ir]);\n        (<$InputRule>plugin).inputRule = ir;\n    };\n\n    return <$InputRule>plugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, MarkSchema, marksCtx, MilkdownPlugin, schemaCtx, SchemaReady } from '@milkdown/core';\nimport { MarkType } from '@milkdown/prose';\n\nexport type $Mark = MilkdownPlugin & {\n    id: string;\n    type: MarkType;\n    schema: MarkSchema;\n};\n\nexport const $mark = (id: string, schema: (ctx: Ctx) => MarkSchema): $Mark => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        const markSchema = schema(ctx);\n        ctx.update(marksCtx, (ns) => [...ns, [id, markSchema] as [string, MarkSchema]]);\n\n        (<$Mark>plugin).id = id;\n        (<$Mark>plugin).schema = markSchema;\n\n        await ctx.wait(SchemaReady);\n\n        (<$Mark>plugin).type = ctx.get(schemaCtx).marks[id];\n    };\n\n    return <$Mark>plugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Ctx, MilkdownPlugin, NodeSchema, nodesCtx, schemaCtx, SchemaReady } from '@milkdown/core';\nimport { NodeType } from '@milkdown/prose';\n\nexport type $Node = MilkdownPlugin & {\n    id: string;\n    type: NodeType;\n    schema: NodeSchema;\n};\n\nexport const $node = (id: string, schema: (ctx: Ctx) => NodeSchema): $Node => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        const nodeSchema = schema(ctx);\n        ctx.update(nodesCtx, (ns) => [...ns, [id, nodeSchema] as [string, NodeSchema]]);\n\n        (<$Node>plugin).id = id;\n        (<$Node>plugin).schema = nodeSchema;\n\n        await ctx.wait(SchemaReady);\n\n        (<$Node>plugin).type = ctx.get(schemaCtx).nodes[id];\n    };\n\n    return <$Node>plugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, MilkdownPlugin, prosePluginsCtx, SchemaReady } from '@milkdown/core';\nimport { Plugin } from '@milkdown/prose';\n\nexport type $Prose = MilkdownPlugin & {\n    plugin: Plugin;\n};\n\nexport const $prose = (prose: (ctx: Ctx) => Plugin): $Prose => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(SchemaReady);\n        const prosePlugin = prose(ctx);\n        ctx.update(prosePluginsCtx, (ps) => [...ps, prosePlugin]);\n        (<$Prose>plugin).plugin = prosePlugin;\n    };\n\n    return <$Prose>plugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, InitReady, MilkdownPlugin, RemarkPlugin, remarkPluginsCtx } from '@milkdown/core';\n\nexport type $Remark = MilkdownPlugin & {\n    plugin: RemarkPlugin;\n};\n\nexport const $remark = (remark: (ctx: Ctx) => RemarkPlugin): $Remark => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(InitReady);\n        const re = remark(ctx);\n        ctx.update(remarkPluginsCtx, (rp) => [...rp, re]);\n        (<$Remark>plugin).plugin = re;\n    };\n\n    return <$Remark>plugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, MilkdownPlugin, prosePluginsCtx, SchemaReady } from '@milkdown/core';\nimport { Keymap, keymap } from '@milkdown/prose';\n\nexport type $Shortcut = MilkdownPlugin & {\n    keymap: Keymap;\n};\n\nexport const $shortcut = (shortcut: (ctx: Ctx) => Keymap): $Shortcut => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(SchemaReady);\n        const k = shortcut(ctx);\n        ctx.update(prosePluginsCtx, (ps) => [...ps, keymap(k)]);\n        (<$Shortcut>plugin).keymap = k;\n    };\n\n    return <$Shortcut>plugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, MilkdownPlugin, SchemaReady, viewCtx } from '@milkdown/core';\nimport { MarkViewFactory, NodeViewFactory, ViewFactory } from '@milkdown/prose';\n\nimport { $Mark, $Node } from '.';\n\nexport type $View<T extends $Node | $Mark, V extends NodeViewFactory | MarkViewFactory> = MilkdownPlugin & {\n    view: V;\n    type: T;\n};\n\nexport const $view = <\n    T extends $Node | $Mark,\n    V extends NodeViewFactory | MarkViewFactory = T extends $Node\n        ? NodeViewFactory\n        : T extends $Mark\n        ? MarkViewFactory\n        : ViewFactory,\n>(\n    type: T,\n    view: (ctx: Ctx) => V,\n): $View<T, V> => {\n    const plugin: MilkdownPlugin = () => async (ctx) => {\n        await ctx.wait(SchemaReady);\n        const v = view(ctx);\n        ctx.update(viewCtx, (ps) => [...ps, [type.id, v] as [string, ViewFactory]]);\n        (<$View<T, V>>plugin).view = v;\n        (<$View<T, V>>plugin).type = type;\n    };\n\n    return <$View<T, V>>plugin;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport {\n    Attrs,\n    CmdKey,\n    commandsCtx,\n    Ctx,\n    InitReady,\n    inputRulesCtx,\n    prosePluginsCtx,\n    remarkPluginsCtx,\n    themeToolCtx,\n} from '@milkdown/core';\nimport { themeMustInstalled } from '@milkdown/exception';\nimport { keymap } from '@milkdown/prose';\n\nimport {\n    AddMetadata,\n    CommandConfig,\n    CommonOptions,\n    Factory,\n    GetPlugin,\n    Methods,\n    UnknownRecord,\n    Utils,\n    WithExtend,\n} from '../types';\n\nexport const getClassName =\n    (className: CommonOptions['className']) =>\n    (attrs: Attrs, ...defaultValue: (string | null | undefined)[]): string => {\n        const classList = className?.(attrs) ?? defaultValue;\n        return Array.isArray(classList) ? classList.filter((x) => x).join(' ') : classList;\n    };\n\nexport const createShortcut = <T>(commandKey: CmdKey<T>, defaultKey: string, args?: T) =>\n    [commandKey, defaultKey, args] as CommandConfig<unknown>;\n\nexport const getUtils = <Options extends UnknownRecord>(ctx: Ctx, options?: Options): Utils => {\n    try {\n        const themeTool = ctx.get(themeToolCtx);\n\n        return {\n            getClassName: getClassName(options?.className as undefined),\n            getStyle: (style) => (options?.headless ? '' : (style(themeTool) as string | undefined)),\n            themeTool,\n        };\n    } catch {\n        throw themeMustInstalled();\n    }\n};\n\nexport const applyMethods = async <Keys extends string, Type, Options extends UnknownRecord>(\n    ctx: Ctx,\n    plugin: Methods<Keys, Type>,\n    getType: () => Promise<Type>,\n    options?: Partial<CommonOptions<Keys, Options>>,\n): Promise<void> => {\n    await ctx.wait(InitReady);\n\n    if (plugin.remarkPlugins) {\n        const remarkPlugins = plugin.remarkPlugins(ctx);\n        ctx.update(remarkPluginsCtx, (ps) => [...ps, ...remarkPlugins]);\n    }\n\n    const type = await getType();\n\n    if (plugin.commands) {\n        const commands = plugin.commands(type, ctx);\n        commands.forEach(([key, command]) => {\n            ctx.get(commandsCtx).create(key, command);\n        });\n    }\n\n    if (plugin.inputRules) {\n        const inputRules = plugin.inputRules(type, ctx);\n        ctx.update(inputRulesCtx, (ir) => [...ir, ...inputRules]);\n    }\n\n    if (plugin.shortcuts) {\n        const getKey = (key: Keys, defaultValue: string): string | string[] => {\n            return options?.keymap?.[key] ?? defaultValue;\n        };\n\n        const tuples = Object.entries<CommandConfig>(plugin.shortcuts)\n            .flatMap(([id, [commandKey, defaultKey, args]]) => {\n                const runner = () => ctx.get(commandsCtx).call(commandKey, args);\n                const key = getKey(id as Keys, defaultKey);\n                if (Array.isArray(key)) {\n                    return key.map((k) => ({ key: k, runner }));\n                }\n                return { key, runner };\n            })\n            .map((x) => [x.key, x.runner] as [string, () => boolean]);\n        ctx.update(prosePluginsCtx, (ps) => ps.concat(keymap(Object.fromEntries(tuples))));\n    }\n\n    if (plugin.prosePlugins) {\n        const prosePlugins = plugin.prosePlugins(type, ctx);\n        ctx.update(prosePluginsCtx, (ps) => [...ps, ...prosePlugins]);\n    }\n};\n\nexport const addMetadata = <SupportedKeys extends string = string, Options extends UnknownRecord = UnknownRecord>(\n    x: GetPlugin<SupportedKeys, Options>,\n): AddMetadata<SupportedKeys, Options> => {\n    const fn: AddMetadata<SupportedKeys, Options> = (options) => {\n        const result = x(options) as ReturnType<AddMetadata<SupportedKeys, Options>>;\n        result.origin = fn;\n        return result;\n    };\n    return fn;\n};\n\nexport const withExtend = <SupportedKeys extends string, Options extends UnknownRecord, Type, Rest>(\n    factory: Factory<SupportedKeys, Options, Type, Rest>,\n    origin: AddMetadata<SupportedKeys, Options>,\n    creator: (factory: Factory<SupportedKeys, Options, Type, Rest>) => WithExtend<SupportedKeys, Options, Type, Rest>,\n): WithExtend<SupportedKeys, Options, Type, Rest> => {\n    type Ext = WithExtend<SupportedKeys, Options, Type, Rest>;\n    const next = origin as Ext;\n    const extend = (extendFactory: Parameters<Ext['extend']>[0]) =>\n        creator((...args) => extendFactory(factory(...args), ...args));\n\n    next.extend = extend as Ext['extend'];\n\n    return next;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, MarkSchema, marksCtx, MilkdownPlugin, schemaCtx, SchemaReady, viewCtx } from '@milkdown/core';\nimport { MarkType, MarkViewFactory, ViewFactory } from '@milkdown/prose';\n\nimport { Factory, UnknownRecord, WithExtend } from '../types';\nimport { addMetadata, applyMethods, getUtils, withExtend } from './common';\n\ntype MarkRest = {\n    id: string;\n    schema: (ctx: Ctx) => MarkSchema;\n    view?: (ctx: Ctx) => MarkViewFactory;\n};\n\ntype MarkFactory<SupportedKeys extends string, Options extends UnknownRecord> = Factory<\n    SupportedKeys,\n    Options,\n    MarkType,\n    MarkRest\n>;\n\nexport const createMark = <SupportedKeys extends string = string, Options extends UnknownRecord = UnknownRecord>(\n    factory: MarkFactory<SupportedKeys, Options>,\n): WithExtend<SupportedKeys, Options, MarkType, MarkRest> =>\n    withExtend(\n        factory,\n        addMetadata(\n            (options): MilkdownPlugin =>\n                () =>\n                async (ctx) => {\n                    const utils = getUtils(ctx, options);\n\n                    const plugin = factory(utils, options);\n                    plugin.view = options?.view ?? plugin.view;\n\n                    await applyMethods(\n                        ctx,\n                        plugin,\n                        async () => {\n                            const node = plugin.schema(ctx);\n                            ctx.update(marksCtx, (ns) => [...ns, [plugin.id, node] as [string, MarkSchema]]);\n\n                            await ctx.wait(SchemaReady);\n\n                            const schema = ctx.get(schemaCtx);\n                            return schema.marks[plugin.id];\n                        },\n                        options,\n                    );\n\n                    if (plugin.view) {\n                        const view = plugin.view(ctx);\n                        ctx.update(viewCtx, (v) => [...v, [plugin.id, view] as [string, ViewFactory]]);\n                    }\n                },\n        ),\n        createMark,\n    );\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport { Ctx, MilkdownPlugin, NodeSchema, nodesCtx, schemaCtx, SchemaReady, viewCtx } from '@milkdown/core';\nimport { NodeType, NodeViewFactory, ViewFactory } from '@milkdown/prose';\n\nimport { Factory, UnknownRecord, WithExtend } from '../types';\nimport { addMetadata, applyMethods, getUtils, withExtend } from './common';\n\ntype NodeRest = {\n    id: string;\n    schema: (ctx: Ctx) => NodeSchema;\n    view?: (ctx: Ctx) => NodeViewFactory;\n};\n\ntype NodeFactory<SupportedKeys extends string, Options extends UnknownRecord> = Factory<\n    SupportedKeys,\n    Options,\n    NodeType,\n    NodeRest\n>;\n\nexport const createNode = <SupportedKeys extends string = string, Options extends UnknownRecord = UnknownRecord>(\n    factory: NodeFactory<SupportedKeys, Options>,\n): WithExtend<SupportedKeys, Options, NodeType, NodeRest> =>\n    withExtend(\n        factory,\n        addMetadata(\n            (options): MilkdownPlugin =>\n                () =>\n                async (ctx) => {\n                    const utils = getUtils(ctx, options);\n\n                    const plugin = factory(utils, options);\n                    plugin.view = options?.view ?? plugin.view;\n\n                    await applyMethods(\n                        ctx,\n                        plugin,\n                        async () => {\n                            const node = plugin.schema(ctx);\n                            ctx.update(nodesCtx, (ns) => [...ns, [plugin.id, node] as [string, NodeSchema]]);\n\n                            await ctx.wait(SchemaReady);\n\n                            const schema = ctx.get(schemaCtx);\n                            return schema.nodes[plugin.id];\n                        },\n                        options,\n                    );\n\n                    if (plugin.view) {\n                        const view = plugin.view(ctx);\n                        ctx.update(viewCtx, (v) => [...v, [plugin.id, view] as [string, ViewFactory]]);\n                    }\n                },\n        ),\n        createNode,\n    );\n","/* Copyright 2021, Milkdown by Mirone. */\n\nimport {\n    Ctx,\n    MarkSchema,\n    marksCtx,\n    MilkdownPlugin,\n    NodeSchema,\n    nodesCtx,\n    schemaCtx,\n    SchemaReady,\n    viewCtx,\n} from '@milkdown/core';\nimport { MarkType, MarkViewFactory, NodeType, NodeViewFactory, ViewFactory } from '@milkdown/prose';\n\nimport { Factory, UnknownRecord, WithExtend } from '../types';\nimport { addMetadata, applyMethods, getUtils, withExtend } from './common';\n\ntype TypeMapping<NodeKeys extends string, MarkKeys extends string> = {\n    [K in NodeKeys]: NodeType;\n} & {\n    [K in MarkKeys]: MarkType;\n};\n\ntype ViewMapping<NodeKeys extends string, MarkKeys extends string> = {\n    [K in NodeKeys]: NodeViewFactory;\n} & {\n    [K in MarkKeys]: MarkViewFactory;\n};\n\ntype PluginRest<NodeKeys extends string, MarkKeys extends string> = {\n    schema?: (ctx: Ctx) => {\n        node?: Record<NodeKeys, NodeSchema>;\n        mark?: Record<MarkKeys, MarkSchema>;\n    };\n    view?: (ctx: Ctx) => Partial<ViewMapping<NodeKeys, MarkKeys>>;\n};\ntype PluginFactory<\n    SupportedKeys extends string = string,\n    Options extends UnknownRecord = UnknownRecord,\n    NodeKeys extends string = string,\n    MarkKeys extends string = string,\n> = Factory<SupportedKeys, Options, TypeMapping<NodeKeys, MarkKeys>, PluginRest<NodeKeys, MarkKeys>>;\n\nexport const createPlugin = <\n    SupportedKeys extends string = string,\n    Options extends UnknownRecord = UnknownRecord,\n    NodeKeys extends string = string,\n    MarkKeys extends string = string,\n>(\n    factory: PluginFactory<SupportedKeys, Options, NodeKeys, MarkKeys>,\n): WithExtend<SupportedKeys, Options, TypeMapping<NodeKeys, MarkKeys>, PluginRest<NodeKeys, MarkKeys>> =>\n    withExtend(\n        factory,\n        addMetadata(\n            (options): MilkdownPlugin =>\n                () =>\n                async (ctx) => {\n                    const utils = getUtils(ctx, options);\n\n                    const plugin = factory(utils, options);\n\n                    await applyMethods(\n                        ctx,\n                        plugin,\n                        async () => {\n                            let node: Record<NodeKeys, NodeSchema> = {} as Record<NodeKeys, NodeSchema>;\n                            let mark: Record<MarkKeys, MarkSchema> = {} as Record<MarkKeys, MarkSchema>;\n                            if (plugin.schema) {\n                                const schemas = plugin.schema(ctx);\n                                if (schemas.node) {\n                                    node = schemas.node;\n                                    const nodes = Object.entries<NodeSchema>(schemas.node);\n                                    ctx.update(nodesCtx, (ns) => [...ns, ...nodes]);\n                                }\n\n                                if (schemas.mark) {\n                                    mark = schemas.mark;\n                                    const marks = Object.entries<MarkSchema>(schemas.mark);\n                                    ctx.update(marksCtx, (ms) => [...ms, ...marks]);\n                                }\n                            }\n\n                            await ctx.wait(SchemaReady);\n\n                            const schema = ctx.get(schemaCtx);\n                            const nodeTypes = Object.keys(node).map((id) => [id, schema.nodes[id]] as const);\n                            const markTypes = Object.keys(mark).map((id) => [id, schema.marks[id]] as const);\n                            const type: TypeMapping<NodeKeys, MarkKeys> = Object.fromEntries([\n                                ...nodeTypes,\n                                ...markTypes,\n                            ]);\n                            return type;\n                        },\n                        options,\n                    );\n\n                    if (plugin.view) {\n                        const view = plugin.view(ctx);\n                        ctx.update(viewCtx, (v) => [\n                            ...v,\n                            ...Object.entries<ViewFactory>(view as Record<string, ViewFactory>),\n                        ]);\n                    }\n                },\n        ),\n        createPlugin,\n    );\n"],"names":[],"mappings":"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"}