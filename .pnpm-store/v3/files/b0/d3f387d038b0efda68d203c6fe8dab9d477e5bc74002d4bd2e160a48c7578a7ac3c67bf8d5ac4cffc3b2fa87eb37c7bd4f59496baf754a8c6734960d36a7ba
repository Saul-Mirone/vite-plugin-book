{"version":3,"file":"index.es.js","sources":["../src/utility/stack.ts","../src/parser/stack-element.ts","../src/parser/stack.ts","../src/parser/state.ts","../src/parser/index.ts","../src/serializer/stack-element.ts","../src/serializer/stack.ts","../src/serializer/state.ts","../src/serializer/index.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport { stackOverFlow } from '@milkdown/exception';\n\ntype ElInstance<U> = {\n    push: (node: U, ...rest: U[]) => void;\n};\n\ntype StackCtx<T extends ElInstance<U>, U> = {\n    readonly elements: T[];\n};\n\nexport const getStackUtil = <Node, El extends ElInstance<Node>, Ctx extends StackCtx<El, Node>>() => {\n    const size = (ctx: Ctx): number => ctx.elements.length;\n\n    const top = (ctx: Ctx): El | undefined => ctx.elements[size(ctx) - 1];\n\n    const push =\n        (ctx: Ctx) =>\n        (node: Node): void => {\n            top(ctx)?.push(node);\n        };\n\n    const open =\n        (ctx: Ctx) =>\n        (node: El): void => {\n            ctx.elements.push(node);\n        };\n\n    const close = (ctx: Ctx): El => {\n        const el = ctx.elements.pop();\n        if (!el) throw stackOverFlow();\n\n        return el;\n    };\n\n    return {\n        size,\n        top,\n        push,\n        open,\n        close,\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Node, NodeType } from '@milkdown/prose';\n\nimport type { Attrs } from './types';\n\nexport type StackElement = {\n    type: NodeType;\n    content: Node[];\n    attrs?: Attrs;\n    push: (node: Node, ...rest: Node[]) => void;\n    pop: () => Node | undefined;\n};\n\nconst pushElement = (element: StackElement, node: Node, ...rest: Node[]) => {\n    element.content.push(node, ...rest);\n};\n\nconst popElement = (element: StackElement): Node | undefined => element.content.pop();\n\nexport const createElement = (type: NodeType, content: Node[], attrs?: Attrs): StackElement => {\n    const element: StackElement = {\n        type,\n        content,\n        attrs,\n        push: (...args) => pushElement(element, ...args),\n        pop: () => popElement(element),\n    };\n    return element;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createNodeInParserFail, stackOverFlow } from '@milkdown/exception';\nimport { Mark, MarkType, Node, NodeType, Schema } from '@milkdown/prose';\n\nimport { getStackUtil } from '../utility';\nimport { createElement, StackElement } from './stack-element';\nimport type { Attrs } from './types';\n\ntype Ctx = {\n    marks: Mark[];\n    readonly schema: Schema;\n    readonly elements: StackElement[];\n};\n\nconst { size, push, top, open, close } = getStackUtil<Node, StackElement, Ctx>();\n\nconst hasText = (node: Node): node is Node & { text: string } => node.isText;\n\nconst maybeMerge = (schema: Schema, a: Node, b: Node): Node | undefined => {\n    if (hasText(a) && hasText(b) && Mark.sameSet(a.marks, b.marks)) {\n        return schema.text(a.text + b.text, a.marks);\n    }\n    return;\n};\n\nconst openNode = (ctx: Ctx) => (nodeType: NodeType, attrs?: Attrs) => open(ctx)(createElement(nodeType, [], attrs));\n\nconst addNode =\n    (ctx: Ctx) =>\n    (nodeType: NodeType, attrs?: Attrs, content?: Node[]): Node => {\n        const node = nodeType.createAndFill(attrs, content, ctx.marks);\n\n        if (!node) throw createNodeInParserFail(nodeType, attrs, content);\n\n        push(ctx)(node);\n\n        return node;\n    };\n\nconst closeNode = (ctx: Ctx) => (): Node => {\n    ctx.marks = Mark.none;\n    const element = close(ctx);\n\n    return addNode(ctx)(element.type, element.attrs, element.content);\n};\n\nconst openMark =\n    (ctx: Ctx) =>\n    (markType: MarkType, attrs?: Attrs): void => {\n        const mark = markType.create(attrs);\n\n        ctx.marks = mark.addToSet(ctx.marks);\n    };\n\nconst closeMark =\n    (ctx: Ctx) =>\n    (markType: MarkType): void => {\n        ctx.marks = markType.removeFromSet(ctx.marks);\n    };\n\nconst addText =\n    (ctx: Ctx) =>\n    (text: string): void => {\n        const topElement = top(ctx);\n        if (!topElement) throw stackOverFlow();\n\n        const prevNode = topElement.pop();\n        const currNode = ctx.schema.text(text, ctx.marks);\n\n        if (!prevNode) {\n            topElement.push(currNode);\n            return;\n        }\n\n        const merged = maybeMerge(ctx.schema, prevNode, currNode);\n        if (merged) {\n            topElement.push(merged);\n            return;\n        }\n        topElement.push(prevNode, currNode);\n    };\n\nconst build = (ctx: Ctx) => () => {\n    let doc: Node | null = null;\n    do {\n        doc = closeNode(ctx)();\n    } while (size(ctx));\n\n    return doc;\n};\n\nexport const createStack = (schema: Schema) => {\n    const ctx: Ctx = {\n        marks: [],\n        elements: [],\n        schema,\n    };\n\n    return {\n        build: build(ctx),\n        openMark: openMark(ctx),\n        closeMark: closeMark(ctx),\n        addText: addText(ctx),\n        openNode: openNode(ctx),\n        addNode: addNode(ctx),\n        closeNode: closeNode(ctx),\n    };\n};\n\nexport type Stack = ReturnType<typeof createStack>;\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { parserMatchError } from '@milkdown/exception';\nimport type { MarkType, NodeType, Schema } from '@milkdown/prose';\n\nimport { RemarkParser } from '../utility';\nimport type { Stack } from './stack';\nimport type { Attrs, InnerParserSpecMap, MarkdownNode, ParserSpecWithType } from './types';\n\ntype PS<T extends keyof Stack> = Parameters<Stack[T]>;\n\n/**\n * State for parser.\n * Transform remark AST into prosemirror state.\n */\nexport class State {\n    constructor(\n        private readonly stack: Stack,\n        public readonly schema: Schema,\n        private readonly specMap: InnerParserSpecMap,\n    ) {}\n\n    #matchTarget(node: MarkdownNode): ParserSpecWithType {\n        const result = Object.values(this.specMap).find((x) => x.match(node));\n\n        if (!result) throw parserMatchError(node);\n\n        return result;\n    }\n\n    #runNode(node: MarkdownNode) {\n        const { key, runner, is } = this.#matchTarget(node);\n\n        const proseType: NodeType | MarkType = this.schema[is === 'node' ? 'nodes' : 'marks'][key];\n        runner(this, node, proseType as NodeType & MarkType);\n    }\n\n    /**\n     * Transform a markdown string into prosemirror state.\n     *\n     * @param remark - The remark parser used.\n     * @param markdown - The markdown string needs to be parsed.\n     * @returns The state instance.\n     */\n    run = (remark: RemarkParser, markdown: string) => {\n        const tree = remark.runSync(remark.parse(markdown)) as MarkdownNode;\n        this.next(tree);\n\n        return this;\n    };\n\n    /**\n     * Give the node or node list back to the state and the state will find a proper runner (by `match` method) to handle it.\n     *\n     * @param nodes - The node or node list needs to be handled.\n     *\n     * @returns The state instance.\n     */\n    next = (nodes: MarkdownNode | MarkdownNode[] = []) => {\n        [nodes].flat().forEach((node) => this.#runNode(node));\n        return this;\n    };\n\n    /**\n     * Parse current remark AST into prosemirror state.\n     *\n     * @returns Result prosemirror doc.\n     */\n    toDoc = () => this.stack.build();\n\n    /**\n     * Inject root node for prosemirror state.\n     *\n     * @param node - The target markdown node.\n     * @param nodeType - The root prosemirror nodeType .\n     * @param attrs - The attribute of root type.\n     * @returns The state instance.\n     */\n    injectRoot = (node: MarkdownNode, nodeType: NodeType, attrs?: Attrs) => {\n        this.stack.openNode(nodeType, attrs);\n        this.next(node.children);\n\n        return this;\n    };\n\n    /**\n     * Add a text type prosemirror node.\n     *\n     * @param text - Text string.\n     * @returns The state instance.\n     */\n    addText = (text = '') => {\n        this.stack.addText(text);\n        return this;\n    };\n\n    /**\n     * Add a node without open or close it.\n     *\n     * @remarks\n     * It's useful for nodes which don't have content.\n     *\n     * @param nodeType - Node type of this node.\n     * @param attrs - Attributes of this node.\n     * @param content - Content of this node.\n     *\n     * @returns The added node.\n     */\n    addNode = (...args: PS<'addNode'>) => {\n        this.stack.addNode(...args);\n        return this;\n    };\n\n    /**\n     * Open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.\n     *\n     * @remarks\n     * You can imagine `openNode` as the left half of parenthesis and `closeNode` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.\n     *\n     * @param nodeType - Node type of this node.\n     * @param attrs - Attributes of this node.\n     *\n     * @returns\n     */\n    openNode = (...args: PS<'openNode'>) => {\n        this.stack.openNode(...args);\n        return this;\n    };\n\n    /**\n     * Close current node.\n     *\n     * @returns The node closed.\n     */\n    closeNode = (...args: PS<'closeNode'>) => {\n        this.stack.closeNode(...args);\n        return this;\n    };\n\n    /**\n     * Open a mark, and all marks created after this method will be set as the children of the mark until a `closeMark` been called.\n     *\n     * @remarks\n     * You can imagine `openMark` as the left half of parenthesis and `closeMark` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.\n     *\n     * @param markType - Mark type of this mark.\n     * @param attrs - Attributes of this mark.\n     *\n     * @returns\n     */\n    openMark = (...args: PS<'openMark'>) => {\n        this.stack.openMark(...args);\n        return this;\n    };\n\n    /**\n     * Close target mark.\n     *\n     * @param markType - Mark type of this mark.\n     *\n     * @returns The mark closed.\n     */\n    closeMark = (...args: PS<'closeMark'>) => {\n        this.stack.closeMark(...args);\n        return this;\n    };\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Schema } from '@milkdown/prose';\n\nimport type { RemarkParser } from '../utility';\nimport { createStack } from './stack';\nimport { State } from './state';\nimport type { InnerParserSpecMap } from './types';\n\nexport const createParser = (schema: Schema, specMap: InnerParserSpecMap, remark: RemarkParser) => (text: string) => {\n    const state = new State(createStack(schema), schema, specMap);\n    state.run(remark, text);\n    return state.toDoc();\n};\n\nexport * from './types';\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { MarkdownNode } from '..';\nimport type { JSONRecord } from '../utility';\n\nexport type StackElement = {\n    type: string;\n    value?: string;\n    props: JSONRecord;\n    children?: MarkdownNode[];\n    push: (node: MarkdownNode, ...rest: MarkdownNode[]) => void;\n    pop: () => MarkdownNode | undefined;\n};\n\nconst pushElement = (element: StackElement, node: MarkdownNode, ...rest: MarkdownNode[]) => {\n    if (!element.children) {\n        element.children = [];\n    }\n    element.children.push(node, ...rest);\n};\n\nconst popElement = (element: StackElement): MarkdownNode | undefined => element.children?.pop();\n\nexport const createElement = (\n    type: string,\n    children?: MarkdownNode[],\n    value?: string,\n    props: JSONRecord = {},\n): StackElement => {\n    const element: StackElement = {\n        type,\n        children,\n        props,\n        value,\n        push: (...args) => pushElement(element, ...args),\n        pop: () => popElement(element),\n    };\n    return element;\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { Mark } from '@milkdown/prose';\nimport { Root } from 'mdast';\n\nimport type { MarkdownNode } from '..';\nimport { getStackUtil, JSONRecord } from '../utility';\nimport { createElement, StackElement } from './stack-element';\n\ntype Ctx = {\n    marks: Mark[];\n    readonly elements: StackElement[];\n};\n\nconst { size, push, open, close } = getStackUtil<MarkdownNode, StackElement, Ctx>();\n\nconst maybeMergeChildren = (element: MarkdownNode) => {\n    const { children } = element;\n    if (!children) return element;\n\n    element.children = children.reduce((nextChildren, child, index) => {\n        if (index === 0) {\n            return [child];\n        }\n        const last = nextChildren[nextChildren.length - 1];\n        if (child.isMark && child.type === last.type) {\n            const { children: currChildren, ...currRest } = child;\n            const { children: prevChildren, ...prevRest } = last;\n            if (currChildren && prevChildren && JSON.stringify(currRest) === JSON.stringify(prevRest)) {\n                const next = {\n                    ...prevRest,\n                    children: [...prevChildren, ...currChildren],\n                };\n                return nextChildren.slice(0, -1).concat(maybeMergeChildren(next));\n            }\n        }\n        return nextChildren.concat(child);\n    }, [] as MarkdownNode[]);\n\n    return element;\n};\n\nconst createMarkdownNode = (element: StackElement) => {\n    const node: MarkdownNode = {\n        ...element.props,\n        type: element.type,\n    };\n\n    if (element.children) {\n        node.children = element.children;\n    }\n\n    if (element.value) {\n        node.value = element.value;\n    }\n\n    return node;\n};\n\nconst openNode =\n    (ctx: Ctx) =>\n    (type: string, value?: string, props?: JSONRecord): void =>\n        open(ctx)(createElement(type, [], value, props));\n\nconst addNode =\n    (ctx: Ctx) =>\n    (type: string, children?: MarkdownNode[], value?: string, props?: JSONRecord): MarkdownNode => {\n        const element = createElement(type, children, value, props);\n        const node: MarkdownNode = maybeMergeChildren(createMarkdownNode(element));\n\n        push(ctx)(node);\n\n        return node;\n    };\n\nconst closeNode = (ctx: Ctx) => (): MarkdownNode => {\n    const element = close(ctx);\n\n    return addNode(ctx)(element.type, element.children, element.value, element.props);\n};\n\nconst openMark =\n    (ctx: Ctx) =>\n    (mark: Mark, type: string, value?: string, props?: JSONRecord): void => {\n        const isIn = mark.isInSet(ctx.marks);\n\n        if (isIn) {\n            return;\n        }\n        ctx.marks = mark.addToSet(ctx.marks);\n        openNode(ctx)(type, value, { ...props, isMark: true });\n    };\n\nconst closeMark =\n    (ctx: Ctx) =>\n    (mark: Mark): MarkdownNode | null => {\n        if (!mark.isInSet(ctx.marks)) return null;\n        ctx.marks = mark.type.removeFromSet(ctx.marks);\n        return closeNode(ctx)();\n    };\n\nconst build = (ctx: Ctx) => () => {\n    let doc: Root | null = null;\n    do {\n        doc = closeNode(ctx)() as Root;\n    } while (size(ctx));\n\n    return doc;\n};\n\nexport type Stack = {\n    /**\n     * Build the remark AST tree with current stack.\n     *\n     * @returns A remark AST tree.\n     */\n    build: () => Root;\n\n    /**\n     * Open a mark.\n     *\n     * @param mark - The mark need to be opened.\n     * @param type - Type of this mark.\n     * @param value - Value of this mark.\n     * @param props - Additional props of this mark.\n     *\n     * @returns\n     */\n    openMark: (mark: Mark, type: string, value?: string, props?: JSONRecord) => void;\n\n    /**\n     * Close current mark.\n     * @param mark - The prosemirror mark of target mark to be closed.\n     *\n     * @returns The mark closed, will be null if not exists.\n     */\n    closeMark: (mark: Mark) => MarkdownNode | null;\n\n    /**\n     * Open a node.\n     *\n     * @param type - Type of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns\n     */\n    openNode: (type: string, value?: string, props?: JSONRecord) => void;\n\n    /**\n     * Add a node in current position.\n     *\n     * @param type - Type of this node.\n     * @param children - Children of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns The added node.\n     */\n    addNode: (type: string, children?: MarkdownNode[], value?: string, props?: JSONRecord) => MarkdownNode;\n\n    /**\n     * Close current node.\n     *\n     * @returns The node closed.\n     */\n    closeNode: () => MarkdownNode;\n};\n\nexport const createStack = (): Stack => {\n    const ctx: Ctx = {\n        marks: [],\n        elements: [],\n    };\n\n    return {\n        build: build(ctx),\n        openMark: openMark(ctx),\n        closeMark: closeMark(ctx),\n        openNode: openNode(ctx),\n        addNode: addNode(ctx),\n        closeNode: closeNode(ctx),\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { serializerMatchError } from '@milkdown/exception';\nimport type { Fragment, Mark as ProseMark, Node as ProseNode, Schema } from '@milkdown/prose';\n\nimport { RemarkParser } from '../utility';\nimport type { Stack } from './stack';\nimport type { InnerSerializerSpecMap, MarkSerializerSpec, NodeSerializerSpec } from './types';\n\nconst isFragment = (x: ProseNode | Fragment): x is Fragment => Object.prototype.hasOwnProperty.call(x, 'size');\n\ntype StateMethod<T extends keyof Stack> = (...args: Parameters<Stack[T]>) => State;\n\n/**\n * State for serializer.\n * Transform prosemirror state into remark AST.\n */\nexport class State {\n    constructor(\n        private readonly stack: Stack,\n        public readonly schema: Schema,\n        private readonly specMap: InnerSerializerSpecMap,\n    ) {}\n\n    #matchTarget<T extends ProseMark | ProseNode>(\n        node: T,\n    ): (T extends ProseNode ? NodeSerializerSpec : MarkSerializerSpec) & { key: string } {\n        const result = Object.entries(this.specMap)\n            .map(([key, spec]) => ({\n                key,\n                ...spec,\n            }))\n            .find((x) => x.match(node as ProseMark & ProseNode));\n\n        if (!result) throw serializerMatchError(node.type);\n\n        return result as never;\n    }\n\n    #runProseNode(node: ProseNode) {\n        const { runner } = this.#matchTarget(node);\n        runner(this, node);\n    }\n\n    #runProseMark(mark: ProseMark, node: ProseNode) {\n        const { runner } = this.#matchTarget(mark);\n        return runner(this, mark, node);\n    }\n\n    #runNode(node: ProseNode) {\n        const { marks } = node;\n        const getPriority = (x: ProseMark) => x.type.spec.priority ?? 50;\n        const tmp = [...marks].sort((a, b) => getPriority(a) - getPriority(b));\n        const unPreventNext = tmp.every((mark) => !this.#runProseMark(mark, node));\n        if (unPreventNext) {\n            this.#runProseNode(node);\n        }\n        marks.forEach((mark) => this.stack.closeMark(mark));\n    }\n\n    /**\n     * Transform a prosemirror node tree into remark AST.\n     *\n     * @param tree - The prosemirror node tree needs to be transformed.\n     *\n     * @returns The state instance.\n     */\n    run(tree: ProseNode) {\n        this.next(tree);\n\n        return this;\n    }\n\n    /**\n     * Use a remark parser to serialize current AST stored.\n     *\n     * @param remark - The remark parser needs to used.\n     * @returns Result markdown string.\n     */\n    toString = (remark: RemarkParser): string => remark.stringify(this.stack.build()) as string;\n\n    /**\n     * Give the node or node list back to the state and the state will find a proper runner (by `match` method) to handle it.\n     *\n     * @param nodes - The node or node list needs to be handled.\n     *\n     * @returns The state instance.\n     */\n    next = (nodes: ProseNode | Fragment) => {\n        if (isFragment(nodes)) {\n            nodes.forEach((node) => {\n                this.#runNode(node);\n            });\n            return this;\n        }\n        this.#runNode(nodes);\n        return this;\n    };\n\n    /**\n     * Add a node without open or close it.\n     *\n     * @remarks\n     * It's useful for nodes which don't have content.\n     *\n     * @param type - Type of this node.\n     * @param children - Children of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns The added node.\n     */\n    addNode: StateMethod<'addNode'> = (...args) => {\n        this.stack.addNode(...args);\n        return this;\n    };\n\n    /**\n     * Open a node, and all nodes created after this method will be set as the children of the node until a `closeNode` been called.\n     *\n     * @remarks\n     * You can imagine `openNode` as the left half of parenthesis and `closeNode` as the right half. For nodes have children, your runner should just take care of the node itself and let other runners to handle the children.\n     *\n     * @param type - Type of this node.\n     * @param value - Value of this node.\n     * @param props - Additional props of this node.\n     *\n     * @returns The state instance.\n     */\n    openNode: StateMethod<'openNode'> = (...args) => {\n        this.stack.openNode(...args);\n        return this;\n    };\n\n    /**\n     * Close current node.\n     *\n     * @returns The node closed.\n     */\n    closeNode: StateMethod<'closeNode'> = (...args) => {\n        this.stack.closeNode(...args);\n        return this;\n    };\n\n    /**\n     * Used when current node has marks, the serializer will auto combine marks nearby.\n     *\n     * @param mark - The mark need to be opened.\n     * @param type - Type of this mark.\n     * @param value - Value of this mark.\n     * @param props - Additional props of this mark.\n     *\n     * @returns The state instance.\n     */\n    withMark: StateMethod<'openMark'> = (...args) => {\n        this.stack.openMark(...args);\n        return this;\n    };\n}\n","/* Copyright 2021, Milkdown by Mirone. */\nimport type { Node, Schema } from '@milkdown/prose';\n\nimport { RemarkParser } from '../utility';\nimport { createStack } from './stack';\nimport { State } from './state';\nimport type { InnerSerializerSpecMap } from './types';\n\nexport const createSerializer =\n    (schema: Schema, specMap: InnerSerializerSpecMap, remark: RemarkParser) => (content: Node) => {\n        const state = new State(createStack(), schema, specMap);\n        state.run(content);\n        return state.toString(remark);\n    };\n\nexport * from './types';\n"],"names":["pushElement","popElement","createElement","size","push","open","close","openNode","addNode","closeNode","openMark","closeMark","build","createStack","State"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAWa,eAAe,MAAyE;QAC3F,QAAO,CAAC,QAAqB,IAAI,SAAS;QAE1C,OAAM,CAAC,QAA6B,IAAI,SAAS,MAAK,OAAO;QAE7D,QACF,CAAC,QACD,CAAC,SAAqB;;eACd,4BAAM,KAAK;AAAA;QAGjB,QACF,CAAC,QACD,CAAC,SAAmB;QACZ,SAAS,KAAK;AAAA;QAGpB,SAAQ,CAAC,QAAiB;UACtB,KAAK,IAAI,SAAS;QACpB,CAAC;YAAU;WAER;AAAA;SAGJ;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AC3BR,MAAMA,gBAAc,CAAC,SAAuB,SAAe,SAAiB;UAChE,QAAQ,KAAK,MAAM,GAAG;AAAA;AAGlC,MAAMC,eAAa,CAAC,YAA4C,QAAQ,QAAQ;MAEnEC,kBAAgB,CAAC,MAAgB,SAAiB,UAAgC;QACrF,UAAwB;AAAA,IAC1B;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM,IAAI,SAASF,cAAY,SAAS,GAAG;AAAA,IAC3C,KAAK,MAAMC,aAAW;AAAA;SAEnB;AAAA;ACbX,MAAM,QAAEE,cAAMC,QAAM,WAAKC,eAAMC,YAAU;AAEzC,MAAM,UAAU,CAAC,SAAgD,KAAK;AAEtE,MAAM,aAAa,CAAC,QAAgB,GAAS,MAA8B;MACnE,QAAQ,MAAM,QAAQ,MAAM,KAAK,QAAQ,EAAE,OAAO,EAAE,QAAQ;WACrD,OAAO,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE;AAAA;;;AAK9C,MAAMC,aAAW,CAAC,QAAa,CAAC,UAAoB,UAAkBF,OAAK,KAAKH,gBAAc,UAAU,IAAI;AAE5G,MAAMM,YACF,CAAC,QACD,CAAC,UAAoB,OAAe,YAA2B;QACrD,OAAO,SAAS,cAAc,OAAO,SAAS,IAAI;MAEpD,CAAC;UAAY,uBAAuB,UAAU,OAAO;SAEpD,KAAK;SAEH;AAAA;AAGf,MAAMC,cAAY,CAAC,QAAa,MAAY;MACpC,QAAQ,KAAK;QACX,UAAUH,QAAM;SAEfE,UAAQ,KAAK,QAAQ,MAAM,QAAQ,OAAO,QAAQ;AAAA;AAG7D,MAAME,aACF,CAAC,QACD,CAAC,UAAoB,UAAwB;QACnC,OAAO,SAAS,OAAO;MAEzB,QAAQ,KAAK,SAAS,IAAI;AAAA;AAGtC,MAAMC,cACF,CAAC,QACD,CAAC,aAA6B;MACtB,QAAQ,SAAS,cAAc,IAAI;AAAA;AAG/C,MAAM,UACF,CAAC,QACD,CAAC,SAAuB;QACd,aAAa,IAAI;MACnB,CAAC;UAAkB;QAEjB,WAAW,WAAW;QACtB,WAAW,IAAI,OAAO,KAAK,MAAM,IAAI;MAEvC,CAAC,UAAU;eACA,KAAK;;;QAId,SAAS,WAAW,IAAI,QAAQ,UAAU;MAC5C,QAAQ;eACG,KAAK;;;aAGT,KAAK,UAAU;AAAA;AAGlC,MAAMC,UAAQ,CAAC,QAAa,MAAM;MAC1B,MAAmB;KACpB;UACOH,YAAU;AAAA,WACXN,OAAK;SAEP;AAAA;MAGEU,gBAAc,CAAC,WAAmB;QACrC,MAAW;AAAA,IACb,OAAO;AAAA,IACP,UAAU;AAAA,IACV;AAAA;SAGG;AAAA,IACH,OAAOD,QAAM;AAAA,IACb,UAAUF,WAAS;AAAA,IACnB,WAAWC,YAAU;AAAA,IACrB,SAAS,QAAQ;AAAA,IACjB,UAAUJ,WAAS;AAAA,IACnB,SAASC,UAAQ;AAAA,IACjB,WAAWC,YAAU;AAAA;AAAA;cC3FV;AAAA,EACf,YACqB,OACD,QACC,SACnB;;;;;;eAwBI,CAAC,QAAsB,aAAqB;YACxC,OAAO,OAAO,QAAQ,OAAO,MAAM;WACpC,KAAK;aAEH;AAAA;gBAUJ,CAAC,QAAuC,OAAO;OACjD,OAAO,OAAO,QAAQ,CAAC,SAAS,4CAAA,WAAc;aACxC;AAAA;iBAQH,MAAM,KAAK,MAAM;sBAUZ,CAAC,MAAoB,UAAoB,UAAkB;WAC/D,MAAM,SAAS,UAAU;WACzB,KAAK,KAAK;aAER;AAAA;mBASD,CAAC,OAAO,OAAO;WAChB,MAAM,QAAQ;aACZ;AAAA;mBAeD,IAAI,SAAwB;WAC7B,MAAM,QAAQ,GAAG;aACf;AAAA;oBAcA,IAAI,SAAyB;WAC/B,MAAM,SAAS,GAAG;aAChB;AAAA;qBAQC,IAAI,SAA0B;WACjC,MAAM,UAAU,GAAG;aACjB;AAAA;oBAcA,IAAI,SAAyB;WAC/B,MAAM,SAAS,GAAG;aAChB;AAAA;qBAUC,IAAI,SAA0B;WACjC,MAAM,UAAU,GAAG;aACjB;AAAA;AAAA;AAAA;;0BA9IE,MAAwC;QAC3C,SAAS,OAAO,OAAO,KAAK,SAAS,KAAK,CAAC,MAAM,EAAE,MAAM;MAE3D,CAAC;UAAc,iBAAiB;SAE7B;AAAA;;sBAGF,MAAoB;QACnB,EAAE,KAAK,QAAQ,OAAO,oDAAA,WAAkB;QAExC,YAAiC,KAAK,OAAO,OAAO,SAAS,UAAU,SAAS;SAC/E,MAAM,MAAM;AAAA;MCzBd,eAAe,CAAC,QAAgB,SAA6B,WAAyB,CAAC,SAAiB;QAC3G,QAAQ,IAAIK,QAAMD,cAAY,SAAS,QAAQ;QAC/C,IAAI,QAAQ;SACX,MAAM;AAAA;ACEjB,MAAM,cAAc,CAAC,SAAuB,SAAuB,SAAyB;MACpF,CAAC,QAAQ,UAAU;YACX,WAAW;AAAA;UAEf,SAAS,KAAK,MAAM,GAAG;AAAA;AAGnC,MAAM,aAAa,CAAC;;AAAoD,uBAAQ,aAAR,mBAAkB;AAAA;MAE7E,gBAAgB,CACzB,MACA,UACA,OACA,QAAoB,OACL;QACT,UAAwB;AAAA,IAC1B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM,IAAI,SAAS,YAAY,SAAS,GAAG;AAAA,IAC3C,KAAK,MAAM,WAAW;AAAA;SAEnB;AAAA;ACvBX,MAAM,EAAE,MAAM,MAAM,MAAM,UAAU;AAEpC,MAAM,qBAAqB,CAAC,YAA0B;QAC5C,EAAE,aAAa;MACjB,CAAC;WAAiB;UAEd,WAAW,SAAS,OAAO,CAAC,cAAc,OAAO,UAAU;QAC3D,UAAU,GAAG;aACN,CAAC;AAAA;UAEN,OAAO,aAAa,aAAa,SAAS;QAC5C,MAAM,UAAU,MAAM,SAAS,KAAK,MAAM;YACM,YAAxC,YAAU,iBAA8B,IAAb,qBAAa,IAAb,CAA3B;YACwC,WAAxC,YAAU,iBAA8B,IAAb,qBAAa,IAAb,CAA3B;UACJ,gBAAgB,gBAAgB,KAAK,UAAU,cAAc,KAAK,UAAU,WAAW;cACjF,OAAO,iCACN,WADM;AAAA,UAET,UAAU,CAAC,GAAG,cAAc,GAAG;AAAA;eAE5B,aAAa,MAAM,GAAG,IAAI,OAAO,mBAAmB;AAAA;AAAA;WAG5D,aAAa,OAAO;AAAA,KAC5B;SAEI;AAAA;AAGX,MAAM,qBAAqB,CAAC,YAA0B;QAC5C,OAAqB,iCACpB,QAAQ,QADY;AAAA,IAEvB,MAAM,QAAQ;AAAA;MAGd,QAAQ,UAAU;SACb,WAAW,QAAQ;AAAA;MAGxB,QAAQ,OAAO;SACV,QAAQ,QAAQ;AAAA;SAGlB;AAAA;AAGX,MAAM,WACF,CAAC,QACD,CAAC,MAAc,OAAgB,UAC3B,KAAK,KAAK,cAAc,MAAM,IAAI,OAAO;AAEjD,MAAM,UACF,CAAC,QACD,CAAC,MAAc,UAA2B,OAAgB,UAAqC;QACrF,UAAU,cAAc,MAAM,UAAU,OAAO;QAC/C,OAAqB,mBAAmB,mBAAmB;OAE5D,KAAK;SAEH;AAAA;AAGf,MAAM,YAAY,CAAC,QAAa,MAAoB;QAC1C,UAAU,MAAM;SAEf,QAAQ,KAAK,QAAQ,MAAM,QAAQ,UAAU,QAAQ,OAAO,QAAQ;AAAA;AAG/E,MAAM,WACF,CAAC,QACD,CAAC,MAAY,MAAc,OAAgB,UAA6B;QAC9D,OAAO,KAAK,QAAQ,IAAI;MAE1B,MAAM;;;MAGN,QAAQ,KAAK,SAAS,IAAI;WACrB,KAAK,MAAM,OAAO,iCAAK,QAAL,EAAY,QAAQ;AAAA;AAGvD,MAAM,YACF,CAAC,QACD,CAAC,SAAoC;MAC7B,CAAC,KAAK,QAAQ,IAAI;WAAe;MACjC,QAAQ,KAAK,KAAK,cAAc,IAAI;SACjC,UAAU;AAAA;AAGzB,MAAM,QAAQ,CAAC,QAAa,MAAM;MAC1B,MAAmB;KACpB;UACO,UAAU;AAAA,WACX,KAAK;SAEP;AAAA;MA8DE,cAAc,MAAa;QAC9B,MAAW;AAAA,IACb,OAAO;AAAA,IACP,UAAU;AAAA;SAGP;AAAA,IACH,OAAO,MAAM;AAAA,IACb,UAAU,SAAS;AAAA,IACnB,WAAW,UAAU;AAAA,IACrB,UAAU,SAAS;AAAA,IACnB,SAAS,QAAQ;AAAA,IACjB,WAAW,UAAU;AAAA;AAAA;AC5K7B,MAAM,aAAa,CAAC,MAA2C,OAAO,UAAU,eAAe,KAAK,GAAG;YAQpF;AAAA,EACf,YACqB,OACD,QACC,SACnB;;;;;;;;oBAyDS,CAAC,WAAiC,OAAO,UAAU,KAAK,MAAM;gBASlE,CAAC,UAAgC;UAChC,WAAW,QAAQ;cACb,QAAQ,CAAC,SAAS;mEACN;AAAA;eAEX;AAAA;+DAEG;aACP;AAAA;mBAgBuB,IAAI,SAAS;WACtC,MAAM,QAAQ,GAAG;aACf;AAAA;oBAeyB,IAAI,SAAS;WACxC,MAAM,SAAS,GAAG;aAChB;AAAA;qBAQ2B,IAAI,SAAS;WAC1C,MAAM,UAAU,GAAG;aACjB;AAAA;oBAayB,IAAI,SAAS;WACxC,MAAM,SAAS,GAAG;aAChB;AAAA;AAAA;AAAA,EAzFX,IAAI,MAAiB;SACZ,KAAK;WAEH;AAAA;AAAA;;2BA7CP,MACiF;QAC3E,SAAS,OAAO,QAAQ,KAAK,SAC9B,IAAI,CAAC,CAAC,KAAK;IACR;AAAA,KACG,OAEN,KAAK,CAAC,MAAM,EAAE,MAAM;MAErB,CAAC;UAAc,qBAAqB,KAAK;SAEtC;AAAA;;2BAGG,MAAiB;QACrB,EAAE,WAAW,sDAAA,WAAkB;SAC9B,MAAM;AAAA;;2BAGH,MAAiB,MAAiB;QACtC,EAAE,WAAW,sDAAA,WAAkB;SAC9B,OAAO,MAAM,MAAM;AAAA;;uBAGrB,MAAiB;QAChB,EAAE,UAAU;QACZ,cAAc,CAAC;;AAAiB,mBAAE,KAAK,KAAK,aAAZ,YAAwB;AAAA;QACxD,MAAM,CAAC,GAAG,OAAO,KAAK,CAAC,GAAG,MAAM,YAAY,KAAK,YAAY;QAC7D,gBAAgB,IAAI,MAAM,CAAC,SAAS,CAAC,sDAAA,WAAmB,MAAM;MAChE,eAAe;qEACI;AAAA;QAEjB,QAAQ,CAAC,SAAS,KAAK,MAAM,UAAU;AAAA;MChDxC,mBACT,CAAC,QAAgB,SAAiC,WAAyB,CAAC,YAAkB;QACpF,QAAQ,IAAI,MAAM,eAAe,QAAQ;QACzC,IAAI;SACH,MAAM,SAAS;AAAA;;"}