{"version":3,"file":"index.es.js","sources":["../src/internal-plugin/config.ts","../src/internal-plugin/init.ts","../src/internal-plugin/schema.ts","../src/internal-plugin/parser.ts","../src/internal-plugin/serializer.ts","../src/internal-plugin/editor-state.ts","../src/internal-plugin/editor-view.ts","../src/internal-plugin/commands.ts","../src/internal-plugin/theme.ts","../src/editor/editor.ts"],"sourcesContent":["/* Copyright 2021, Milkdown by Mirone. */\nimport { createTimer, CtxHandler, MilkdownPlugin } from '@milkdown/ctx';\n\nexport const ConfigReady = createTimer('ConfigReady');\n\nexport const config =\n    (configure: CtxHandler): MilkdownPlugin =>\n    (pre) => {\n        pre.record(ConfigReady);\n\n        return async (ctx) => {\n            await configure(ctx);\n            ctx.done(ConfigReady);\n        };\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Slice, Timer } from '@milkdown/ctx';\nimport { InputRule, MarkViewFactory, NodeViewFactory, Plugin, ViewFactory } from '@milkdown/prose';\nimport { RemarkParser, RemarkPlugin } from '@milkdown/transformer';\nimport { remark } from 'remark';\n\nimport type { Editor } from '../editor';\nimport { ConfigReady } from './config';\n\nexport const InitReady = createTimer('InitReady');\n\nexport const initTimerCtx = createSlice<Timer[]>([], 'initTimer');\nexport const editorCtx = createSlice<Editor>({} as Editor, 'editor');\n\nexport const inputRulesCtx = createSlice<InputRule[]>([], 'inputRules');\nexport const prosePluginsCtx = createSlice<Plugin[]>([], 'prosePlugins');\nexport const remarkPluginsCtx = createSlice<RemarkPlugin[]>([], 'remarkPlugins');\n\ntype View = [nodeId: string, view: ViewFactory | NodeViewFactory | MarkViewFactory];\nexport const viewCtx = createSlice<View[]>([], 'nodeView');\n\nexport const remarkCtx: Slice<RemarkParser> = createSlice(remark(), 'remark');\n\nexport const init =\n    (editor: Editor): MilkdownPlugin =>\n    (pre) => {\n        pre.inject(editorCtx, editor)\n            .inject(prosePluginsCtx)\n            .inject(remarkPluginsCtx)\n            .inject(inputRulesCtx)\n            .inject(viewCtx)\n            .inject(remarkCtx, remark())\n            .inject(initTimerCtx, [ConfigReady])\n            .record(InitReady);\n\n        return async (ctx) => {\n            await ctx.waitTimers(initTimerCtx);\n\n            ctx.done(InitReady);\n        };\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport type { MarkSpec, NodeSpec } from '@milkdown/prose';\nimport { Schema } from '@milkdown/prose';\nimport type {\n    MarkParserSpec,\n    MarkSerializerSpec,\n    NodeParserSpec,\n    NodeSerializerSpec,\n    RemarkParser,\n} from '@milkdown/transformer';\n\nimport { InitReady, remarkCtx, remarkPluginsCtx } from '.';\n\nexport const SchemaReady = createTimer('schemaReady');\n\nexport const schemaCtx = createSlice<Schema>({} as Schema, 'schema');\nexport const schemaTimerCtx = createSlice<Timer[]>([], 'schemaTimer');\n\nexport type NodeSchema = {\n    readonly toMarkdown: NodeSerializerSpec;\n    readonly parseMarkdown: NodeParserSpec;\n} & Readonly<NodeSpec>;\n\nexport const nodesCtx = createSlice<[string, NodeSchema][]>([], 'nodes');\n\nexport type MarkSchema = {\n    readonly toMarkdown: MarkSerializerSpec;\n    readonly parseMarkdown: MarkParserSpec;\n} & Readonly<MarkSpec>;\nexport const marksCtx = createSlice<[string, MarkSchema][]>([], 'marks');\n\nexport const schema: MilkdownPlugin = (pre) => {\n    pre.inject(schemaCtx).inject(nodesCtx).inject(marksCtx).inject(schemaTimerCtx, [InitReady]).record(SchemaReady);\n\n    return async (ctx) => {\n        await ctx.waitTimers(schemaTimerCtx);\n\n        const remark = ctx.get(remarkCtx);\n        const remarkPlugins = ctx.get(remarkPluginsCtx);\n\n        const processor = remarkPlugins.reduce((acc: RemarkParser, plug) => acc.use(plug), remark);\n        ctx.set(remarkCtx, processor);\n\n        const nodes = Object.fromEntries(ctx.get(nodesCtx));\n        const marks = Object.fromEntries(ctx.get(marksCtx));\n\n        ctx.set(\n            schemaCtx,\n            new Schema({\n                nodes,\n                marks,\n            }),\n        );\n\n        ctx.done(SchemaReady);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport type { Node as ProsemirrorNode } from '@milkdown/prose';\nimport { createParser, InnerParserSpecMap, ParserSpecWithType } from '@milkdown/transformer';\n\nimport { marksCtx, nodesCtx } from '.';\nimport { remarkCtx } from './init';\nimport { schemaCtx, SchemaReady } from './schema';\n\nexport type Parser = (text: string) => ProsemirrorNode | null;\n\nexport const parserCtx = createSlice<Parser>(() => null, 'parser');\nexport const parserTimerCtx = createSlice<Timer[]>([], 'parserTimer');\n\nexport const ParserReady = createTimer('ParserReady');\n\nexport const parser: MilkdownPlugin = (pre) => {\n    pre.inject(parserCtx).inject(parserTimerCtx, [SchemaReady]).record(ParserReady);\n\n    return async (ctx) => {\n        await ctx.waitTimers(parserTimerCtx);\n        const nodes = ctx.get(nodesCtx);\n        const marks = ctx.get(marksCtx);\n        const remark = ctx.get(remarkCtx);\n        const schema = ctx.get(schemaCtx);\n\n        const children = [\n            ...nodes.map(([id, v]) => ({ id, ...v })).map((node) => ({ ...node, is: 'node' as const })),\n            ...marks.map(([id, v]) => ({ id, ...v })).map((mark) => ({ ...mark, is: 'mark' as const })),\n        ];\n        const spec: InnerParserSpecMap = Object.fromEntries(\n            children.map(({ id, parseMarkdown, is }) => [id, { ...parseMarkdown, is, key: id } as ParserSpecWithType]),\n        );\n\n        ctx.set(parserCtx, createParser(schema, spec, remark));\n        ctx.done(ParserReady);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport type { Node as ProsemirrorNode } from '@milkdown/prose';\nimport { createSerializer } from '@milkdown/transformer';\n\nimport { remarkCtx } from './init';\nimport { marksCtx, nodesCtx, schemaCtx, SchemaReady } from './schema';\n\nexport const serializerCtx = createSlice<(node: ProsemirrorNode) => string>(() => '', 'serializer');\nexport const serializerTimerCtx = createSlice<Timer[]>([], 'serializerTimer');\n\nexport const SerializerReady = createTimer('SerializerReady');\n\nexport const serializer: MilkdownPlugin = (pre) => {\n    pre.inject(serializerCtx).inject(serializerTimerCtx, [SchemaReady]).record(SerializerReady);\n\n    return async (ctx) => {\n        await ctx.waitTimers(serializerTimerCtx);\n        const nodes = ctx.get(nodesCtx);\n        const marks = ctx.get(marksCtx);\n        const remark = ctx.get(remarkCtx);\n        const schema = ctx.get(schemaCtx);\n\n        const children = [...nodes, ...marks];\n        const spec = Object.fromEntries(children.map(([id, child]) => [id, child.toMarkdown]));\n\n        ctx.set(serializerCtx, createSerializer(schema, spec, remark));\n        ctx.done(SerializerReady);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport { docTypeError } from '@milkdown/exception';\nimport {\n    baseKeymap,\n    customInputRules as createInputRules,\n    DOMParser,\n    EditorState,\n    keymap as createKeymap,\n    Node,\n    Schema,\n} from '@milkdown/prose';\nimport { JSONRecord } from '@milkdown/transformer';\n\nimport { CommandsReady } from '.';\nimport { inputRulesCtx, prosePluginsCtx } from './init';\nimport { Parser, parserCtx, ParserReady } from './parser';\nimport { schemaCtx } from './schema';\nimport { SerializerReady } from './serializer';\n\ntype DefaultValue = string | { type: 'html'; dom: HTMLElement } | { type: 'json'; value: JSONRecord };\ntype StateOptions = Parameters<typeof EditorState.create>[0];\n\nexport const defaultValueCtx = createSlice<DefaultValue>('', 'defaultValue');\nexport const editorStateCtx = createSlice<EditorState>({} as EditorState, 'editorState');\nexport const editorStateOptionsCtx = createSlice<StateOptions>({}, 'stateOptions');\nexport const editorStateTimerCtx = createSlice<Timer[]>([], 'editorStateTimer');\n\nexport const EditorStateReady = createTimer('EditorStateReady');\n\nconst getDoc = (defaultValue: DefaultValue, parser: Parser, schema: Schema) => {\n    if (typeof defaultValue === 'string') {\n        return parser(defaultValue);\n    }\n\n    if (defaultValue.type === 'html') {\n        return DOMParser.fromSchema(schema).parse(defaultValue.dom);\n    }\n\n    if (defaultValue.type === 'json') {\n        return Node.fromJSON(schema, defaultValue.value);\n    }\n\n    throw docTypeError(defaultValue);\n};\n\nexport const editorState: MilkdownPlugin = (pre) => {\n    pre.inject(defaultValueCtx)\n        .inject(editorStateCtx)\n        .inject(editorStateOptionsCtx)\n        .inject(editorStateTimerCtx, [ParserReady, SerializerReady, CommandsReady])\n        .record(EditorStateReady);\n\n    return async (ctx) => {\n        await ctx.waitTimers(editorStateTimerCtx);\n\n        const schema = ctx.get(schemaCtx);\n        const parser = ctx.get(parserCtx);\n        const rules = ctx.get(inputRulesCtx);\n        const options = ctx.get(editorStateOptionsCtx);\n        const prosePlugins = ctx.get(prosePluginsCtx);\n        const defaultValue = ctx.get(defaultValueCtx);\n        const doc = getDoc(defaultValue, parser, schema);\n\n        const state = EditorState.create({\n            schema,\n            doc,\n            plugins: [...prosePlugins, createInputRules({ rules }), createKeymap(baseKeymap)],\n            ...options,\n        });\n        ctx.set(editorStateCtx, state);\n        ctx.done(EditorStateReady);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, createTimer, MilkdownPlugin, Timer } from '@milkdown/ctx';\nimport { EditorView, ViewFactory } from '@milkdown/prose';\n\nimport { editorStateCtx, EditorStateReady } from './editor-state';\nimport { viewCtx } from './init';\n\ntype EditorOptions = Omit<ConstructorParameters<typeof EditorView>[1], 'state'>;\n\nexport const editorViewCtx = createSlice<EditorView>({} as EditorView, 'editorView');\nexport const editorViewOptionsCtx = createSlice<EditorOptions>({}, 'editorViewOptions');\nexport const rootCtx = createSlice<Node | undefined | null | string>(document.body, 'root');\nexport const editorViewTimerCtx = createSlice<Timer[]>([], 'editorViewTimer');\n\nexport const EditorViewReady = createTimer('EditorViewReady');\n\nconst createViewContainer = (root: Node) => {\n    const container = document.createElement('div');\n    container.className = 'milkdown';\n    root.appendChild(container);\n\n    return container;\n};\n\nconst prepareViewDom = (dom: Element) => {\n    dom.classList.add('editor');\n    dom.setAttribute('role', 'textbox');\n};\n\nexport const editorView: MilkdownPlugin = (pre) => {\n    pre.inject(rootCtx, document.body)\n        .inject(editorViewCtx)\n        .inject(editorViewOptionsCtx)\n        .inject(editorViewTimerCtx, [EditorStateReady])\n        .record(EditorViewReady);\n\n    return async (ctx) => {\n        await ctx.waitTimers(editorViewTimerCtx);\n\n        const state = ctx.get(editorStateCtx);\n        const options = ctx.get(editorViewOptionsCtx);\n        const nodeViews = Object.fromEntries(ctx.get(viewCtx) as [string, ViewFactory][]);\n        const root = ctx.get(rootCtx);\n        const el = typeof root === 'string' ? document.querySelector(root) : root;\n\n        const container = el ? createViewContainer(el) : undefined;\n        const view = new EditorView(container, {\n            state,\n            nodeViews,\n            ...options,\n        });\n        prepareViewDom(view.dom);\n        ctx.set(editorViewCtx, view);\n        ctx.done(EditorViewReady);\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createContainer, createSlice, createTimer, MilkdownPlugin, Slice, Timer } from '@milkdown/ctx';\nimport { callCommandBeforeEditorView } from '@milkdown/exception';\nimport type { Command } from '@milkdown/prose';\n\nimport { editorViewCtx, EditorViewReady } from './editor-view';\nimport { SchemaReady } from './schema';\n\nexport type Cmd<T = undefined> = (info?: T) => Command;\nexport type CmdKey<T = undefined> = Slice<Cmd<T>>;\n\nexport type CommandManager = {\n    create: <T>(meta: CmdKey<T>, value: Cmd<T>) => void;\n    get: <T>(meta: CmdKey<T>) => Cmd<T>;\n    call: <T>(meta: CmdKey<T>, info?: T) => boolean;\n};\n\nexport type CmdTuple<T = unknown> = [key: CmdKey<T>, value: Cmd<T>];\n\nexport const createCmd = <T>(key: CmdKey<T>, value: Cmd<T>): CmdTuple => [key, value] as CmdTuple;\n\nexport const commandsCtx = createSlice<CommandManager>({} as CommandManager, 'commands');\n\nexport const createCmdKey = <T = undefined>(): CmdKey<T> => createSlice((() => () => false) as Cmd<T>, 'cmdKey');\n\nexport const commandsTimerCtx = createSlice<Timer[]>([], 'commandsTimer');\nexport const CommandsReady = createTimer('CommandsReady');\n\nexport const commands: MilkdownPlugin = (pre) => {\n    const container = createContainer();\n    const commandManager: CommandManager = {\n        create: (slice, value) => slice(container.sliceMap, value),\n        get: (slice) => container.getSlice(slice).get(),\n        call: () => {\n            throw callCommandBeforeEditorView();\n        },\n    };\n    pre.inject(commandsCtx, commandManager).inject(commandsTimerCtx, [SchemaReady]).record(CommandsReady);\n    return async (ctx) => {\n        await ctx.waitTimers(commandsTimerCtx);\n\n        ctx.done(CommandsReady);\n        await ctx.wait(EditorViewReady);\n\n        ctx.update(commandsCtx, (prev) => ({\n            ...prev,\n            call: (meta, info) => {\n                const cmd = commandManager.get(meta);\n                const command = cmd(info);\n                const view = ctx.get(editorViewCtx);\n                return command(view.state, view.dispatch, view);\n            },\n        }));\n    };\n};\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createSlice, MilkdownPlugin } from '@milkdown/ctx';\nimport { injectVar, pack2Tool, ThemePack, ThemeTool } from '@milkdown/design-system';\n\nexport const themeToolCtx = createSlice<ThemeTool>(\n    {\n        mixin: {} as never,\n        font: {} as never,\n        size: {} as never,\n        slots: {} as never,\n        palette: () => '',\n    },\n    'ThemeTool',\n);\n\nexport type { ThemeTool } from '@milkdown/design-system';\n\nexport const themeFactory =\n    (themePack: ThemePack): MilkdownPlugin =>\n    (pre) => {\n        pre.inject(themeToolCtx);\n        return (ctx) => {\n            injectVar(themePack);\n            const tool = pack2Tool(themePack);\n\n            ctx.set(themeToolCtx, tool);\n        };\n    };\n","/* Copyright 2021, Milkdown by Mirone. */\nimport { createClock, createContainer, Ctx, CtxHandler, MilkdownPlugin, Pre } from '@milkdown/ctx';\n\nimport { commands, config, editorState, editorView, init, parser, schema, serializer } from '../internal-plugin';\n\n/**\n * Get the milkdown editor constructor\n */\nexport class Editor {\n    /**\n     * Create a new editor instance.\n     *\n     * @returns The new editor instance been created.\n     */\n    static make() {\n        return new Editor();\n    }\n\n    readonly #container = createContainer();\n    readonly #clock = createClock();\n\n    readonly #plugins: Set<CtxHandler> = new Set();\n    readonly #configureList: CtxHandler[] = [];\n\n    readonly #ctx = new Ctx(this.#container, this.#clock);\n    readonly #pre = new Pre(this.#container, this.#clock);\n\n    readonly #loadInternal = () => {\n        const internalPlugins = [schema, parser, serializer, commands, editorState, editorView];\n        const configPlugin = config(async (x) => {\n            await Promise.all(this.#configureList.map((fn) => fn(x)));\n        });\n        this.use(internalPlugins.concat(init(this)).concat(configPlugin));\n    };\n\n    /**\n     * Get the ctx of the editor.\n     *\n     * @returns The ctx of the editor.\n     */\n    get ctx() {\n        return this.#ctx;\n    }\n\n    /**\n     * Use one plugin or a list of plugins for current editor.\n     *\n     * @example\n     * ```\n     * Editor.make()\n     *   .use(plugin)\n     *   .use([pluginA, pluginB])\n     * ```\n     *\n     * @param plugins - A list of plugins, or one plugin.\n     * @returns Editor instance.\n     */\n    readonly use = (plugins: MilkdownPlugin | MilkdownPlugin[]) => {\n        [plugins].flat().forEach((plugin) => {\n            this.#plugins.add(plugin(this.#pre));\n        });\n        return this;\n    };\n\n    /**\n     * Config the context for current editor.\n     *\n     * @param configure - The function that configure current editor, can be async, with context as parameter.\n     * @returns Editor instance.\n     */\n    readonly config = (configure: CtxHandler) => {\n        this.#configureList.push(configure);\n        return this;\n    };\n\n    /**\n     * Create the editor UI.\n     *\n     * @example\n     * ```\n     * Editor.make().use(nord).use(commonmark).create()\n     * ```\n     *\n     * @returns A promise object, will be resolved as editor instance after create finish.\n     */\n    readonly create = async () => {\n        this.#loadInternal();\n        await Promise.all([...this.#plugins].map((loader) => loader(this.#ctx)));\n        return this;\n    };\n\n    /**\n     * Get the context value in a running editor on demand and return the action result.\n     *\n     * @example\n     * ```\n     * import { Editor, editorViewCtx, serializerCtx } from '@milkdown/core';\n     * async function playWithEditor() {\n     *     const editor = await Editor.make().use(commonmark).create();\n     *\n     *     const getMarkdown = () =>\n     *         editor.action((ctx) => {\n     *             const editorView = ctx.get(editorViewCtx);\n     *             const serializer = ctx.get(serializerCtx);\n     *             return serializer(editorView.state.doc);\n     *         });\n     *\n     *     // get markdown string:\n     *     getMarkdown();\n     * }\n     * ```\n     *\n     * @param action - The function that get editor context and return the action result.\n     * @returns The action result.\n     */\n    readonly action = <T>(action: (ctx: Ctx) => T) => action(this.#ctx);\n}\n"],"names":["createInputRules","createKeymap"],"mappings":"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"}